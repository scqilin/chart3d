<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Man</title>
    <script src="./babylon.js"></script>
    <script src="./babylonjs.loaders.min.js"></script>
    <script src="./CharacterController.js"></script>
    <script src="./joystick.js"></script>
    <style>
        body {
            overflow: hidden;
            margin: 0;
            touch-action: none
        }
        #joyDiv {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 150px;
            height: 150px
        }
    </style>
</head>

<body>
    <div id="joyDiv"></div>
    <canvas style="width: 100vw; height:100vh" id="renderCanvas"></canvas>
    <script type="module">
        var canvas = document.getElementById('renderCanvas');
        var engine = new BABYLON.Engine(canvas, true);
        var scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color3(0.95, 0.95, 0.95);
        scene.ambientColor = new BABYLON.Color3(1, 1, 1);

        var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
        light.intensity = 1;

        var light2 = new BABYLON.DirectionalLight("light2", new BABYLON.Vector3(-1, -1, -1), scene);
        light2.position = new BABYLON.Vector3(0, 100, 0);
        light2.intensity = 0.7;

        var ground = BABYLON.Mesh.CreateGround("ground", 140, 100, 2, scene);
        var groundMaterial = new BABYLON.StandardMaterial("ground", scene);
        groundMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
        ground.material = groundMaterial;
        ground.checkCollisions = true;

        // wall material
        var wallMaterial = new BABYLON.StandardMaterial("wall", scene);
        wallMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.8, 0.8);

        // ground 一圈墙
        var wall1 = BABYLON.MeshBuilder.CreateBox("wall1", { height: 10, width: 140, depth: 1 }, scene);
        wall1.position.set(0, 5, 50);
        wall1.checkCollisions = true;
        wall1.material = wallMaterial;

        var wall2 = BABYLON.MeshBuilder.CreateBox("wall2", { height: 10, width: 140, depth: 1 }, scene);
        wall2.position.set(0, 5, -50);
        wall2.checkCollisions = true;
        wall2.material = wallMaterial;

        var wall3 = BABYLON.MeshBuilder.CreateBox("wall3", { height: 10, width: 1, depth: 100 }, scene);
        wall3.position.set(70, 5, 0);
        wall3.checkCollisions = true;
        wall3.material = wallMaterial;

        var wall4 = BABYLON.MeshBuilder.CreateBox("wall4", { height: 10, width: 1, depth: 100 }, scene);
        wall4.position.set(-70, 5, 0);
        wall4.checkCollisions = true;
        wall4.material = wallMaterial;


        var box = BABYLON.MeshBuilder.CreateBox("box", { height: 1, width: 3, depth: 3 }, scene);
        box.position.set(-5, 0.5, 0);
        box.checkCollisions = true;
        box.material = new BABYLON.StandardMaterial("box", scene);
        box.material.diffuseColor = new BABYLON.Color3(0.6, 0.2, 0.2);

        loadPlayer(scene, engine, canvas);
        loadRoom(scene, engine, canvas);
        // 添加坐标轴 xyz 长度为10
        /*  var axisX = BABYLON.Mesh.CreateLines("axisX", [
             new BABYLON.Vector3.Zero(),
             new BABYLON.Vector3(10, 0, 0),
             new BABYLON.Vector3(9.5, 0.5, 0),
             new BABYLON.Vector3(10, 0, 0),
             new BABYLON.Vector3(9.5, -0.5, 0)
         ], scene);
        */

        var cc;
        
        function loadPlayer(scene, engine, canvas) {
            BABYLON.SceneLoader.ImportMesh("", "./", "man.glb", scene, function (meshes, particleSystems, skeletons) {
                var player = meshes[0];
                player.rotation = player.rotationQuaternion.toEulerAngles();
                player.rotationQuaternion = null;

                player.position = new BABYLON.Vector3(0, 0.2, 0);
                player.checkCollisions = true;
                player.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);
                player.ellipsoidOffset = new BABYLON.Vector3(0, 1, 0);

                var alpha = 0;
                var beta = Math.PI / 2.5;
                var target = new BABYLON.Vector3(player.position.x, player.position.y + 1.5, player.position.z);

                var camera = new BABYLON.ArcRotateCamera("ArcRotateCamera", alpha, beta, 5, target, scene);

                camera.wheelPrecision = 15;
                camera.checkCollisions = true;
                camera.keysLeft = [];
                camera.keysRight = [];
                camera.keysUp = [];
                camera.keysDown = [];
                camera.lowerRadiusLimit = 2;
                camera.upperRadiusLimit = 20;

                camera.attachControl();

                var allAGs = scene.animationGroups;
                for (let i = 0; i < allAGs.length; i++) {
                    allAGs[i].stop();
                    console.log(i + "," + allAGs[i].name);
                }

                var agMap = {
                    idle: allAGs[0], //0
                    strafeLeft: allAGs[3],
                    strafeRight: allAGs[4],
                    turnRight: allAGs[5],
                    walk: allAGs[6],  // 6
                    fall: allAGs[8],
                    slideBack: allAGs[9],
                    runJump: allAGs[10],
                    turnLeft: allAGs[11],
                    walkBack: allAGs[12],
                    run: allAGs[13],
                    idleJump: allAGs[14],
                }


                cc = new CharacterController(player, camera, scene, agMap);
                cc.setTurningOff(true);
                cc.setFaceForward(true);
                cc.setMode(0);
                cc.setTurnSpeed(45);

                cc.setCameraTarget(new BABYLON.Vector3(0, 1.5, 0));

                cc.setNoFirstPerson(true);
                cc.setStepOffset(0.4);
                cc.setSlopeLimit(30, 60);

                cc.enableBlending(0.05);

                cc.setIdleAnim(null, 1, true);
                cc.setTurnLeftAnim(null, 0.5, true);
                cc.setTurnRightAnim(null, 0.5, true);
                cc.setWalkAnim(agMap["walk2"], 1, true);
                cc.setWalkBackAnim(null, 0.5, true);
                cc.setIdleJumpAnim(null, 0.5, false);
                cc.setRunJumpAnim(null, 0.6, false);
                cc.setFallAnim(null, 2, false);
                cc.setSlideBackAnim(null, 1, false);

                cc.setCameraElasticity(false);
                cc.makeObstructionInvisible(false);
                cc.start();

                engine.runRenderLoop(function () {
                    scene.render();
                });
            });
        }

        // 加载room gltf模型
        function loadRoom(scene, engine, canvas) {
            BABYLON.SceneLoader.ImportMesh("", "./", "room.glb", scene, function (meshes, particleSystems, skeletons) {
                var room = meshes[0];
                room.position = new BABYLON.Vector3(0, 3, 0);
                room.checkCollisions = true;
                room.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);
                room.ellipsoidOffset = new BABYLON.Vector3(0, 1, 0);

                // 所有的mesh 都开启碰撞检测
                for (let i = 0; i < meshes.length; i++) {
                    meshes[i].checkCollisions = true;
                }
                // 所有材质 都开启双面渲染
                for (let i = 0; i < scene.materials.length; i++) {
                    scene.materials[i].backFaceCulling = false;
                }
            });
        }

        

        // resize
        window.addEventListener("resize", function () {
            engine.resize();
        });

        // 如果是移动端 
        function isMobileDevice() {
            return /Mobile|Android/.test(navigator.userAgent);
        }

        if (isMobileDevice()) {
            console.log("当前设备是移动端");
            // 摇杆
            var joystick = new JoyStick("joyDiv");

            setInterval(() => {
                var joystickDirection = joystick.GetDir();
                switch (joystickDirection) {
                    case "N":
                        cc?.walk(true);
                        break;

                    case "S":
                        cc?.walkBack(true);
                        break;

                    case "W":
                        cc?.turnLeft(true);
                        break;

                    case "E":
                        cc?.turnRight(true);
                        break;

                    case "NW":
                        break;

                    case "NE":
                        break;

                    case "SE":
                        break;

                    case "SW":
                        break;

                    default:
                        cc?.idle();
                        break;
                }
            }, 25);

        } else {
            console.log("当前设备不是移动端");
        }



    </script>
</body>

</html>